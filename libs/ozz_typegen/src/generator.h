//
// Created by ozzadar on 2025-06-17.
//

#pragma once
#include <sstream>
#include <vector>

namespace OZZ::typegen {
    namespace OZZ::typegen::internal {
        struct Node {
            explicit Node(std::stringstream &inStream);

        private:
            enum class FieldType : uint8_t {
                Unknown = 0,

                // Primitive types
                Int,
                Float,
                Double,
                Bool,
                String,

                GeneratedType,
            };

            enum class NodeType : uint8_t {
                Unknown = 0,

                Struct,
                Enum,
            };

            struct Field {
                FieldType Type;
                bool IsArray;
                std::string Name;
                std::string CustomType; // For Struct or Enum types
            };

            static FieldType parseFieldType(const std::string &typeStr);
        private:
            NodeType type { NodeType::Unknown };
            std::string name;
            std::vector<Field> fields {};

            friend std::ostream &operator<<(std::ostream &os, const Node &node);
        };

        class File {
        public:
            explicit File(std::stringstream &inStream);

        private:
            std::string name;
            std::vector<Node> nodes;

            friend std::ostream &operator<<(std::ostream &os, const File &file);
        };

        // Define the output stream operator for Node and File
        inline std::ostream &operator<<(std::ostream &os, const Node &node) {
            // TODO: Namespace or i might need to do indentation properly
            constexpr uint8_t indentation = 1;

            //
            switch (node.type) {
                case Node::NodeType::Struct:
                    os << "struct " << node.name << " {\n";
                    break;
                case Node::NodeType::Enum:
                    os << "enum class " << node.name << " {\n";
                    break;
                default:
                    os << "// Unknown node type\n";
                    return os;
            }

            // Iterate through fields and print them
            for (const auto &field: node.fields) {
                // Indent the field definition
                os << std::string(indentation * 4, ' '); // 4 spaces per indentation level

                if (node.type == Node::NodeType::Enum) {
                    // For enums, we just print the field name
                    os << field.Name << ",\n";
                    continue;
                }

                // Print the field type
                if (field.IsArray) {
                    os << "std::vector<";
                }
                switch (field.Type) {
                    case Node::FieldType::Int:
                        os << "int ";
                        break;
                    case Node::FieldType::Float:
                        os << "float ";
                        break;
                    case Node::FieldType::Double:
                        os << "double ";
                        break;
                    case Node::FieldType::Bool:
                        os << "bool ";
                        break;
                    case Node::FieldType::String:
                        os << "std::string ";
                        break;
                    case Node::FieldType::GeneratedType:
                        os << field.CustomType << " ";
                        break;
                    default:
                        os << "// Unknown field type\n";
                        continue; // Skip unknown types
                }
                if (field.IsArray) {
                    os << "> ";
                }

                // Print the field name
                os << field.Name;

                // End the line with a semicolon
                os << ";\n";
            }

            // closing curly brace
            os << "};\n";

            return os;
        }

        inline std::ostream &operator<<(std::ostream &os, const File &file) {
            os << R"(
/**
    * Generated by OZZ Typegen
    * This file is auto-generated, do not edit manually.
    * To regenerate, run the typegen tool with the appropriate definition file.
    * Definition file: )" << file.name << R"(
*/
)";
            os << "#pragma once\n";
            // add the includes for the types

            os << "#include <ozz_binary/binary.h>\n";
            os << "#include <string>\n";
            os << "#include <vector>\n";

            for (const auto &node: file.nodes) {
                os << "\n\n";
                os << node;
            }
            return os;
        }
    }

    std::stringstream Generate(std::stringstream &definition);
}
